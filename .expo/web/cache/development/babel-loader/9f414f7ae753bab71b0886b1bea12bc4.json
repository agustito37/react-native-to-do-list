{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport { useMemo, useCallback } from \"react\";\nimport transform from \"./pathTransform\";\nimport { getFromCache, setInCache } from \"./globalCache\";\nimport { isFalseyString, isClassName, getKey, isNamespace, getKeyFromNamespace, getNamespace, flattenStyles, getPathFromLiteralTag } from \"./utils\";\nexport var getFromDefinitionOrCache = function getFromDefinitionOrCache(pKey, namespace, definition) {\n  var isConstant = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var space = namespace;\n  var key = pKey;\n\n  if (isNamespace(key)) {\n    space = getNamespace(key);\n    key = getKeyFromNamespace(key);\n  }\n\n  key = getKey(key);\n  return getFromCache(key, space, definition, isConstant);\n};\nexport var GlobalUse = function GlobalUse(path, namespace) {\n  var styles = path.trim().split(\" \").reduce(function (stylesAcc, p) {\n    var style;\n\n    if (isFalseyString(p)) {\n      return stylesAcc;\n    }\n\n    if (isClassName(p)) {\n      style = getFromDefinitionOrCache(p, namespace);\n    } else {\n      style = transform(p, function (key) {\n        return getFromDefinitionOrCache(key, namespace, null, true);\n      });\n    }\n\n    stylesAcc.push(style);\n    return stylesAcc;\n  }, []);\n  return styles;\n};\nexport var useGlobalStyles = function useGlobalStyles(nameSpace) {\n  var localCache = useMemo(function () {\n    return Object.create(null);\n  }, []);\n  return useCallback(function (strings) {\n    for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      expressions[_key - 1] = arguments[_key];\n    }\n\n    var path = getPathFromLiteralTag(strings, expressions);\n\n    if (localCache[path]) {\n      return localCache[path];\n    }\n\n    var styles = GlobalUse(path, nameSpace);\n\n    _extends(localCache, _defineProperty({}, path, styles));\n\n    return styles;\n  }, []);\n};\nexport var GlobalStyles = function GlobalStyles(definition, namespace) {\n  for (var _i = 0, _Object$entries = Object.entries(definition); _i < _Object$entries.length; _i++) {\n    var _ref = _Object$entries[_i];\n\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var key = _ref2[0];\n    var value = _ref2[1];\n\n    if (typeof value !== \"object\") {\n      var styles = value.trim().split(\" \").reduce(function (stylesAcc, path) {\n        var style;\n\n        if (isFalseyString(path)) {\n          return stylesAcc;\n        }\n\n        if (isClassName(path)) {\n          style = getFromDefinitionOrCache(path, namespace, definition);\n        } else {\n          style = transform(path, function (key) {\n            return getFromDefinitionOrCache(key, namespace, definition, true);\n          });\n        }\n\n        stylesAcc.push(style);\n        return stylesAcc;\n      }, []);\n      definition[key] = flattenStyles(styles);\n    }\n  }\n\n  setInCache(definition, namespace);\n};\nexport var Styles = function Styles(definition, namespace) {\n  var definitionNamespace = namespace;\n\n  if (!definitionNamespace) {\n    definitionNamespace = Symbol();\n  }\n\n  GlobalStyles(definition, definitionNamespace);\n\n  var useStyles = function useStyles() {\n    return useGlobalStyles(definitionNamespace);\n  };\n\n  useStyles.namespace = definitionNamespace;\n  return useStyles;\n};","map":{"version":3,"sources":["/Users/agustin/projects/react-native-to-do-list/node_modules/react-native-use-styles/src/core/stylesManager.js"],"names":["useMemo","useCallback","transform","getFromCache","setInCache","isFalseyString","isClassName","getKey","isNamespace","getKeyFromNamespace","getNamespace","flattenStyles","getPathFromLiteralTag","getFromDefinitionOrCache","pKey","namespace","definition","isConstant","space","key","GlobalUse","path","styles","trim","split","reduce","stylesAcc","p","style","push","useGlobalStyles","nameSpace","localCache","Object","create","strings","expressions","GlobalStyles","entries","value","Styles","definitionNamespace","Symbol","useStyles"],"mappings":"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","sourcesContent":["// TODO: p(124235, 'fl-row') to send the identifier of a Stylesheet.create style\n// TODO: check if there are collisions between keys and values as\n// fl:dir:row:1 could be 'flexDirection: row 1' and 'flexDirectionRow: 1' (?)\n// TODO: add errors; inexistent-namespace when get cache, undefined-path or not key-value present, invalid-key, undefiend-classname\nimport { useMemo, useCallback } from \"react\";\nimport transform from \"./pathTransform\";\nimport { getFromCache, setInCache } from \"./globalCache\";\nimport {\n  isFalseyString,\n  isClassName,\n  getKey,\n  isNamespace,\n  getKeyFromNamespace,\n  getNamespace,\n  flattenStyles,\n  getPathFromLiteralTag\n} from \"./utils\";\n\nexport const getFromDefinitionOrCache = (\n  pKey,\n  namespace,\n  definition,\n  isConstant = false\n) => {\n  let space = namespace;\n  let key = pKey;\n\n  if (isNamespace(key)) {\n    space = getNamespace(key);\n    key = getKeyFromNamespace(key);\n  }\n  key = getKey(key);\n\n  return getFromCache(key, space, definition, isConstant);\n};\n\nexport const GlobalUse = (path, namespace) => {\n  const styles = path\n    .trim()\n    .split(\" \")\n    .reduce((stylesAcc, p) => {\n      let style;\n\n      if (isFalseyString(p)) {\n        return stylesAcc;\n      }\n\n      if (isClassName(p)) {\n        style = getFromDefinitionOrCache(p, namespace);\n      } else {\n        style = transform(p, key =>\n          getFromDefinitionOrCache(key, namespace, null, true)\n        );\n      }\n\n      stylesAcc.push(style);\n      return stylesAcc;\n    }, []);\n\n  return styles;\n};\n\nexport const useGlobalStyles = nameSpace => {\n  // create local cache for returned arrays, so we can avoid re-renders and re-transformations\n  const localCache = useMemo(() => Object.create(null), []);\n\n  return useCallback((strings, ...expressions) => {\n    const path = getPathFromLiteralTag(strings, expressions);\n\n    if (localCache[path]) {\n      return localCache[path];\n    }\n\n    const styles = GlobalUse(path, nameSpace);\n    Object.assign(localCache, { [path]: styles });\n\n    return styles;\n  }, []);\n};\n\nexport const GlobalStyles = (definition, namespace) => {\n  for (let [key, value] of Object.entries(definition)) {\n    // only transform if it's not a style object\n    if (typeof value !== \"object\") {\n      const styles = value\n        .trim()\n        .split(\" \")\n        .reduce((stylesAcc, path) => {\n          let style;\n\n          if (isFalseyString(path)) {\n            return stylesAcc;\n          }\n\n          if (isClassName(path)) {\n            style = getFromDefinitionOrCache(path, namespace, definition);\n          } else {\n            style = transform(path, key =>\n              getFromDefinitionOrCache(key, namespace, definition, true)\n            );\n          }\n\n          stylesAcc.push(style);\n          return stylesAcc;\n        }, []);\n\n      definition[key] = flattenStyles(styles);\n    }\n  }\n\n  setInCache(definition, namespace);\n};\n\nexport const Styles = (definition, namespace) => {\n  let definitionNamespace = namespace;\n\n  if (!definitionNamespace) {\n    definitionNamespace = Symbol();\n  }\n\n  GlobalStyles(definition, definitionNamespace);\n\n  const useStyles = () => useGlobalStyles(definitionNamespace);\n  useStyles.namespace = definitionNamespace;\n\n  return useStyles;\n};\n"]},"metadata":{},"sourceType":"module"}